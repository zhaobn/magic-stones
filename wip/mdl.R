
options("scipen" = 10)
options()$scipen

library(dplyr)
rm(list=ls())

# Settings
features<-list()
features[['color']]<-paste0('c', seq(3))
features[['shape']]<-paste0('s', seq(3))

abbs<-list()
abbs[['c']]<-'color'
abbs[['s']]<-'shape'

relations<-c('=', '~')


stones<-c()
for (c in features[[1]]) {
  for (s in features[[2]]) {
    stones<-c(stones, paste0(c, '-', s))
  }
}

# Data generator
possible_obs<-list()
n_stones<-length(stones)
for (a in 1:n_stones) {
  for (r in 1:n_stones) {
    for (t in 1:n_stones) {
      idx<-(a-1)*n_stones*n_stones+(r-1)*n_stones+t
      obs<-list()
      obs[['A']]<-stones[a]
      obs[['R']]<-stones[r]
      obs[['T']]<-stones[t]
      possible_obs[[idx]]<-obs
    }
  }
}
complete_obs<-do.call(rbind.data.frame, possible_obs)
rownames(complete_obs)<-NULL

sample_obs<-function() {
  obs<-list()
  obs[['A']]<-sample(stones, 1) # prob = c(1,1,1,0,0,0,0,0,0)
  obs[['R']]<-sample(stones, 1)
  obs[['T']]<-sample(stones, 1) # or generated by a function
  return(obs)
}
full_obs<-list()
for (i in 1:1000) full_obs[[i]]<-sample_obs()

# Hypo generator
## 1. Atomic descriptions
atomics<-list()
generate_atomic_hypos<-function(role, feature, type) {
  hypos<-list()
  compose<-function(val_1, val_2, relation) {
    atomic<-list()
    atomic[['role']]<-role
    atomic[['feature']]<-feature
    atomic[['type']]<-type
    atomic[['desc']]<-paste0(val_1, relation, val_2)
    return(atomic)
  }
  f<-substr(feature, 1, 1)
  if (type=='absolute') {
    obj<-if (role=='e') paste0(f, '(T)') else paste0(f, '(', c('A', 'R'), ')')
    val<-features[[feature]]
  } else {
    obj<-if (role=='e') paste0(f, '(T)') else paste0(f, '(A)') 
    val<-if (role=='e') paste0(f, '(', c('A', 'R'), ')') else paste0(f, '(R)')
  }
  for (o in 1:length(obj)) {
    for (v in 1:length(val)) {
      for (r in 1:length(relations)) {
        idx<-(o-1)*length(val)*length(relations)+(v-1)*length(relations)+r
        hypos[[idx]]<-compose(obj[o], val[v], relations[r])
      }
    }
  }
  return(do.call(rbind.data.frame, hypos))
}
atomics<-generate_atomic_hypos('c', 'color', 'relative')
for (r in c('c', 'e')) {
  for (f in names(features)) {
    for (t in c('relative', 'absolute')) {
      if (!(r=='c'&f=='color'&t=='relative')) atomics<-rbind(atomics, generate_atomic_hypos(r, f, t))
    }
  }
}
rownames(atomics) <- NULL
atomics$desc<-as.character(atomics$desc)

## 2. Compose hypotheses
hypos<-c()

color_effects<-(atomics%>%filter(role=='e'&feature=='color')%>%select(desc))[[1]]
shape_effects<-(atomics%>%filter(role=='e'&feature=='shape')%>%select(desc))[[1]]
color_causes<-(atomics%>%filter(role=='c'&feature=='color')%>%select(desc))[[1]]
shape_causes<-(atomics%>%filter(role=='c'&feature=='shape')%>%select(desc))[[1]]

### 2.1 Single universal effect descriptions
single_effects<-c(color_effects, shape_effects)
hypos<-c(hypos, single_effects)

### 2.2 Double universal effect descriptions
double_effects<-c()
for (c in color_effects) {
  for (s in shape_effects) {
    double_effects<-c(double_effects, paste(c(c,s), collapse=','))
  }
}

uni_effects<-c(single_effects, double_effects)
hypos<-c(hypos, double_effects)

### 2.3 Single cause descriptions
single_causes<-c(color_causes, shape_causes)
single_cause_effects<-c()
for (c in single_causes) {
  for (e in uni_effects) {
    single_cause_effects<-c(single_cause_effects, paste0(e, '[', c, ']'))
  }
}
hypos<-c(hypos, single_cause_effects)

### 2.4 Double cause descriptions
double_causes<-c()
for (c in color_causes) {
  for (s in shape_causes) {
    double_causes<-c(double_causes, paste(c(c,s), collapse=','))
  }
}
double_cause_effects<-c()
for (c in double_causes) {
  for (e in uni_effects) {
    double_cause_effects<-c(double_cause_effects, paste0(e, '[', c, ']'))
  }
}
hypos<-c(hypos, double_cause_effects)

hypo_space<-data.frame(hypos)
colnames(hypo_space)<-c('hypo')
hypo_space$hypo<-as.character(hypo_space$hypo)

# Checker
h<-hypo_space[[1]][1]
d<-full_obs[[1]]
check_atomic<-function(at, obs) {
  read_val<-function(v, str) {
    if (grepl('\\(', str)) {
      values<-strsplit(obs[[substr(str, 3, 3)]], '-')[[1]]
      return(if (v=='c') values[1] else values[2])
    } else return(str)
  }
  f<-substr(at, 1, 1); feature<-abbs[[f]]
  relation<-substr(at, 5, 5)
  vals<-strsplit(at, relation)[[1]]
  val_1<-read_val(f, vals[1])
  val_2<-read_val(f, vals[2])
  if (relation=='=') return(val_1==val_2) else return(!(val_1==val_2))
}
check_hypo<-function(hypo, obs) {
  has_precon<-grepl('\\[', hypo)
  effect_desc<-if (has_precon) strsplit(hypo, '\\[')[[1]][1] else hypo
  precond_desc<-if (has_precon) gsub('\\]', '', strsplit(hypo, '\\[')[[1]][2]) else ''
  effs<-strsplit(effect_desc, ',')[[1]]; pres<-strsplit(precond_desc, ',')[[1]]
  
  if (length(effs)==1) {
    f<-substr(effs, 1, 1)
    other_f<-if (f=='c') 's' else 'c'
    default<-paste0(other_f, '(T)', '=', other_f, '(R)')
    effs<-c(effs, default)
  }
  
  sat_eff<-TRUE
  for (e in effs) sat_eff<-sat_eff&check_atomic(e, obs)
  
  if (!has_precon) return(sat_eff) else {
    sat_pres<-TRUE
    for (p in pres) sat_pres<-sat_pres&check_atomic(p, obs)
    if (sat_pres) return(sat_eff) else {
      return(obs[['R']]==obs[['T']])
    }
  }
}
check_hypo("c(T)~c(A),s(T)=s1[s(A)=s1]", obs)

# Normative prior
# Complexity measure

# Put together

# Results

# Tests & debug


