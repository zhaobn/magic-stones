
options("scipen" = 10)
options()$scipen

library(dplyr)
rm(list=ls())

# Settings
features<-list()
features[['color']]<-paste0('c', seq(3))
features[['shape']]<-paste0('s', seq(3))

abbs<-list()
abbs[['c']]<-'color'
abbs[['s']]<-'shape'

relations<-c('=', '~')

stones<-c()
for (c in features[[1]]) {
  for (s in features[[2]]) {
    stones<-c(stones, paste0(c, '-', s))
  }
}

# Generate data
possible_obs<-list()
n_stones<-length(stones)
for (a in 1:n_stones) {
  for (r in 1:n_stones) {
    for (t in 1:n_stones) {
      idx<-(a-1)*n_stones*n_stones+(r-1)*n_stones+t
      obs<-list()
      obs[['A']]<-stones[a]
      obs[['R']]<-stones[r]
      obs[['T']]<-stones[t]
      possible_obs[[idx]]<-obs
    }
  }
}
complete_obs<-do.call(rbind.data.frame, possible_obs)
rownames(complete_obs)<-NULL

sample_obs<-function() {
  obs<-list()
  obs[['A']]<-sample(stones, 1) # prob = c(1,1,1,0,0,0,0,0,0)
  obs[['R']]<-sample(stones, 1)
  obs[['T']]<-sample(stones, 1) # or generated by a function
  return(obs)
}
full_obs<-list()
for (i in 1:1000) full_obs[[i]]<-sample_obs()

# Generate hypotheses
## 1. Atomic descriptions
atomics<-list()
generate_atomic_hypos<-function(role, feature, type) {
  hypos<-list()
  compose<-function(val_1, val_2, relation) {
    atomic<-list()
    atomic[['role']]<-role
    atomic[['feature']]<-feature
    atomic[['type']]<-type
    atomic[['desc']]<-paste0(val_1, relation, val_2)
    return(atomic)
  }
  f<-substr(feature, 1, 1)
  if (type=='absolute') {
    obj<-if (role=='e') paste0(f, '(T)') else paste0(f, '(', c('A', 'R'), ')')
    val<-features[[feature]]
  } else {
    obj<-if (role=='e') paste0(f, '(T)') else paste0(f, '(A)') 
    val<-if (role=='e') paste0(f, '(', c('A', 'R'), ')') else paste0(f, '(R)')
  }
  for (o in 1:length(obj)) {
    for (v in 1:length(val)) {
      for (r in 1:length(relations)) {
        idx<-(o-1)*length(val)*length(relations)+(v-1)*length(relations)+r
        hypos[[idx]]<-compose(obj[o], val[v], relations[r])
      }
    }
  }
  return(do.call(rbind.data.frame, hypos))
}
atomics<-generate_atomic_hypos('c', 'color', 'relative')
for (r in c('c', 'e')) {
  for (f in names(features)) {
    for (t in c('relative', 'absolute')) {
      if (!(r=='c'&f=='color'&t=='relative')) atomics<-rbind(atomics, generate_atomic_hypos(r, f, t))
    }
  }
}
rownames(atomics) <- NULL
atomics$desc<-as.character(atomics$desc)

## 2. Composite hypotheses
color_effects<-(atomics%>%filter(role=='e'&feature=='color')%>%select(desc))[[1]]
shape_effects<-(atomics%>%filter(role=='e'&feature=='shape')%>%select(desc))[[1]]
color_causes<-(atomics%>%filter(role=='c'&feature=='color')%>%select(desc))[[1]]
shape_causes<-(atomics%>%filter(role=='c'&feature=='shape')%>%select(desc))[[1]]

### 2.1 Single universal effect descriptions
single_effects<-c(color_effects, shape_effects)

### 2.2 Double universal effect descriptions
double_effects<-c()
for (c in color_effects) {
  for (s in shape_effects) {
    double_effects<-c(double_effects, paste(c(c,s), collapse=','))
  }
}
uni_effects<-c(single_effects, double_effects)

### 2.3 Single cause descriptions
single_causes<-c(color_causes, shape_causes)
single_cause_effects<-c()
for (c in single_causes) {
  for (e in uni_effects) {
    single_cause_effects<-c(single_cause_effects, paste0(e, '[', c, ']'))
  }
}

### 2.4 Multi cause descriptions
multi_cause_effects<-c()
terminate<-0.5
sample_multi<-function(hypo){
  hypos<-if (length(hypo)>0) strsplit(hypo, '\\|')[[1]] else c()
  sampled<-sample(single_cause_effects, 1)
  if (sampled %in% hypos) return(hypo) else {
    hypo<-paste(c(hypos, sampled), collapse='|')
    if (runif(1)<0.5) return(hypo) else return(sample_multi(hypo))
  }
}
for (i in seq(5000)) {
  multi_cause_effects<-c(multi_cause_effects, sample_multi(sample(single_cause_effects, 1)))
}
multi_cause_effects<-unique(multi_cause_effects)

### Final hypothesis space
hypos<-c()
hypos<-c(hypos, uni_effects)
hypos<-c(hypos, single_cause_effects)
hypos<-c(hypos, multi_cause_effects)

hypo_space<-data.frame(hypos)
colnames(hypo_space)<-c('hypo')
hypo_space$hypo<-as.character(hypo_space$hypo)

# Checkers
check_atomic<-function(at, obs) {
  read_val<-function(v, str) {
    if (grepl('\\(', str)) {
      values<-strsplit(obs[[substr(str, 3, 3)]], '-')[[1]]
      return(if (v=='c') values[1] else values[2])
    } else return(str)
  }
  f<-substr(at, 1, 1); feature<-abbs[[f]]
  relation<-substr(at, 5, 5)
  vals<-strsplit(at, relation)[[1]]
  is_match<-(read_val(f, vals[1])==read_val(f, vals[2]))
  if (relation=='=') {
    if (is_match) return(1) else return(0)
  } else {
    if (is_match) return(0) else return(1/2)
  }
}
check_desc<-function(desc, obs) {
  has_precon<-grepl('\\[', desc)
  effect_desc<-if (has_precon) strsplit(desc, '\\[')[[1]][1] else desc
  precond_desc<-if (has_precon) gsub('\\]', '', strsplit(desc, '\\[')[[1]][2]) else ''
  effs<-strsplit(effect_desc, ',')[[1]]; pres<-strsplit(precond_desc, ',')[[1]]
  
  if (length(effs)==1) {
    f<-substr(effs, 1, 1)
    other_f<-if (f=='c') 's' else 'c'
    default<-paste0(other_f, '(T)', '=', other_f, '(R)')
    effs<-c(effs, default)
  }
  
  sat_eff<-1
  for (e in effs) sat_eff<-sat_eff*check_atomic(e, obs)
  
  if (!has_precon) return(sat_eff) else {
    sat_pres<-1
    for (p in pres) sat_pres<-sat_pres * check_atomic(p, obs)
    if (sat_pres>0) return(sat_pres*sat_eff) else {
      return(sat_pres*as.numeric(obs[['R']]==obs[['T']]))
    }
  }
}
check_hypo<-function(hypo, obs) {
  is_multi<-grepl('\\|', hypo)
  if (!is_multi) return(check_desc(hypo, obs)) else {
    sat<-0
    descs<-strsplit(hypo, '\\|')[[1]]
    for (d in descs) sat<-sat+check_desc(d, obs)
    return(min(sat, 1))
  }
}

# Complexity measure
get_comp<-function(hypo) {
  atomics<-c()
  read_desc<-function(str){
    if (grepl('\\[', str)) {
      ats<-strsplit(str, '\\[')[[1]]
      conds<-gsub('\\]', '', ats[2])
      return(read_desc(paste(c(ats[1], conds), collapse=',')))
    } else {
      return(strsplit(str, ',')[[1]])
    }
  }
  if (grepl('\\|', hypo)) {
    hypos<-strsplit(hypo, '\\|')[[1]]
    for (h in hypos) atomics<-c(atomics, read_desc(h))
  } else atomics<-read_desc(hypo)
  n<-length(atomics)
  return(exp(-n))
}
hypo_space$comp<-mapply(get_comp, hypo_space$hypo)

# Play with data
get_length<-function(hypo, data) {
  len<-0
  for (i in 1:length(data)) {
    pr<-check_hypo(hypo, data[[i]])
    len<-if (pr>0) len-log(pr) else len
  }
  return(len-log(get_comp(hypo)))
}

hypo<-hypo_space$hypo
all_combo<-vector()
for (h in hypo) all_combo<-c(all_combo, get_length(h, possible_obs))
mdl<-data.frame(hypo, all_combo)


# Rank probs
rank_data<-function(data, col, ndigits=4) {
  # absoulute ranks
  rounded<-sort(unique(round(data[,col], ndigits)))
  rank<-seq(length(rounded))
  ranking<-data.frame(rank, rounded)
  
  data<-data%>%mutate(rounded=round(len,4))
  data<-data%>%left_join(ranking, by='rounded')
  
  # relative (accumulative) rank
  c<-data['rounded']%>%group_by(rounded)%>%tally()
  acc<-within(c, acc_sum <- Reduce("+", n, accumulate = TRUE))
  acc<-acc%>%mutate(nbefore=lag(acc_sum, 1))%>%replace(is.na(.), 0)%>%mutate(acc_rank=(nbefore+1))
  data<-data%>%left_join(acc, by='rounded')%>%select(hypo, len, rank, acc_rank)
  
  return(data)
}
mdl.allcom<-mdl%>%select(hypo, len=all_combo)
mdl.allcom<-rank_data(mdl.allcom, 'len')

save(mdl.allcom, file = 'mdl.Rdata')




